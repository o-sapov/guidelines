<p xmlns="http://www.tei-c.org/ns/1.0">MEI differentiates between two essential aspects of music notation:<hi rend="italic">Events</hi>and<hi rend="italic">ControlEvents</hi>. There are other examples for such a separation of concerns with regard to music. In Greg's Copy-Text Theory (W.W.Greg:<hi rend="italic">The Rationale of Copy-Text</hi>, 1950), a distinction between primary and secondary text is made; similar attempts have been made for music specifically. In MEI, elements describing the basic musical text are referred to as<hi rend="italic">Events</hi>. They are the building blocks for the stream of music – mostly those are <gi scheme="MEI">note</gi>s, <gi scheme="MEI">rest</gi>s, and <gi scheme="MEI">chord</gi>s. In contrast,<hi rend="italic">ControlEvents</hi>make no independent contribution to that flow of music. Instead, they provide additional information about the encoded<hi rend="italic">Events</hi>, they<hi rend="italic">control</hi>their performance. Examples for such<hi rend="italic">ControlEvents</hi>are <gi scheme="MEI">dynam</gi>ic markings, <gi scheme="MEI">tempo</gi>s indications, or performance <gi scheme="MEI">dir</gi>ectives. Depending on the encoding strategy used, <gi scheme="MEI">slur</gi>s and <gi scheme="MEI">tie</gi>s often also fall into this category (they may be encoded as attributes instead, in which case they become a property of the basic events). Simply put,<hi rend="italic">Events</hi>describe<hi rend="bold">
      <hi rend="italic">what</hi>
   </hi>needs to be performed, and<hi rend="italic">ControlEvents</hi>indicate<hi rend="bold">
      <hi rend="italic">how</hi>
   </hi>it needs to be performed. In (<ptr target="cmn"/>-based) MEI,<hi rend="italic">Events</hi>are nested inside a <gi scheme="MEI">layer</gi> element, while<hi rend="italic">ControlEvents</hi>are direct children of the first <gi scheme="MEI">measure</gi> they apply to, following all <gi scheme="MEI">staff</gi> elements there. These structural differences result in different markup concepts. As<hi rend="italic">Events</hi>are encoded inside <gi scheme="MEI">layer</gi>s, their<hi rend="italic">semantic position</hi>inside the encoded work can be derived from their<hi rend="italic">structural position</hi>– the measure, staff and layer they're nested in, and within that layer by their position inside the sequence of all layer children. As mentioned above, it is highly<hi rend="italic">recommended</hi>to encode<hi rend="italic">ControlEvents</hi>inside the first measure they apply to, but they still require references to the actual events they apply to. There are two common concepts to provide such a connection, both of which offering specific benefits and drawbacks. A technically very stable connection between<hi rend="italic">ControlEvents</hi>and<hi rend="italic">Events</hi>can be established by using<hi rend="bold">pointers</hi>. In this case, all events that need to be referenced need an<hi rend="italic">@xml:id</hi>attribute, which holds a globally unique identifier for this very element. The referencing controlevent then uses a<hi rend="italic">@startid</hi>and, if necessary,<hi rend="italic">@endid</hi>attribute to create a link to where in the stream of music it is supposed to start or end.  In the example above, the <gi scheme="MEI">dynam</gi> element references the second quarter in the given measure. Additional attributes like<hi rend="italic">@place</hi>may be used to describe the position of the<hi rend="italic">forte</hi>indication within the score. A <gi scheme="MEI">hairpin</gi> element may use the<hi rend="italic">@endid</hi>attribute to indicate the duration of the hairpin using the same mechanism as above. <specList>
      <specDesc key="att.startId" atts="startid"/>
      <specDesc key="att.startEndId" atts="endid"/>
   </specList> A<hi rend="italic">ControlEvent</hi>encoded like above will be strictly tied to the referenced<hi rend="italic">Events</hi>– if their position inside the XML document changes for whatever reason, they will keep that connection. This means that the<hi rend="italic">semantic position</hi>to which they are bound may change without affecting the binding. An example could be an inserted additional note in front – the dynamic marking would not start on the second quarter, but perhaps on the third instead. As this behavior may not be desired in all cases, an alternative binding between<hi rend="italic">ControlEvents</hi>and<hi rend="italic">Events</hi>is possible, relying on<hi rend="italic">timestamps</hi>instead. This mechanism is illustrated in the following example:  Here, no<hi rend="italic">@xml:id</hi>is required on notes. Instead, the <gi scheme="MEI">dynam</gi> element uses the<hi rend="italic">@staff</hi>and<hi rend="italic">@layer</hi>attributes to indicate to which set of events the following<hi rend="italic">@tstamp</hi>attribute refers to. <specList>
      <specDesc key="att.timestamp.logical" atts="tstamp"/>
   </specList> This mechanism actually depends on what has been only recommended above: placing the controlevent inside the measure where it starts. The<hi rend="italic">@startid</hi>reference mechanism would work equally well if all controlevents where positioned in the very first or last measure, or actually even inside a separate file. The<hi rend="italic">@tstamp</hi>references however would not, they depend on correct placement of the controlevents inside the XML tree. For consistency, it is therefore<hi rend="italic">recommended</hi>to always use this placement. The benefit of this concept is that controlevents are tied to a<hi rend="italic">semantic position</hi>, but not necessarily to a given XML element. The<hi rend="italic">forte</hi>may still be placed on the second quarter, even though the composer may have replaced that quarter G4 with a different pitch and / or duration. Actually, it is not required that an<hi rend="italic">Event</hi>can be found at the position indicated by a timestamp. This may be useful to encode a slur ending at an arbitrary position between two events, or dynam markings spread across otherwise empty measures. If the ending of a<hi rend="italic">ControlEvent</hi>shall be given by timestamp, the<hi rend="italic">@tstamp2</hi>attribute is used. <specList>
      <specDesc key="att.timestamp2.logical" atts="tstamp2"/>
   </specList> Because of potential inconsistencies, an encoding should not offer both<hi rend="italic">@startid</hi>and<hi rend="italic">tstamp</hi>or<hi rend="italic">@endid</hi>and<hi rend="italic">@tstamp2</hi>. Though not being recommendable, it is possible to mix<hi rend="italic">@startid</hi>with<hi rend="italic">@tstamp2</hi>and<hi rend="italic">@tstamp</hi>with<hi rend="italic">@endid</hi>. In general, it is easier for software to process<hi rend="italic">@startid</hi>and<hi rend="italic">@endid</hi>. When no other arguments apply, using<hi rend="italic">@xml:id</hi>-based pointers is therefore the most common way to connect<hi rend="italic">ControlEvents</hi>with<hi rend="italic">Events</hi>. The details on how timestamps are calculated and used in MEI are given in <ptr target="timestamps"/>.</p>
